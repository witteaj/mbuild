## A list of unfinished functionality that I wanted to bring to MBuild and how to implement it.
##### find_bonds: 
- This will be useful when the user or developer needs to identify a specific instance of a bond and do operations on it. I see practical applications coming in during polymerization reactions with vinyl carbons for example (see examples of polystyrene).

> The code has been written but operates on an outdated version of how I wanted to specify hierarchal pathways. This function will be used to find specific instances of bonds. The way it is intended to operate is by providing two heirarchal pathways (can be incomplete) the function will yield all instances of these two particles bonding. The user can be as specific as the 2 exact particles that participate in the bond or can be more vague, as in only specifying the pathway to a particle and a pathway to a subcompound, in which case the function will yield all the instances where particleA in pathway1 is bonded to subcompoundB in pathway2. Another situation is where the user specifies pathways to two different subcompounds, in which case the function will yield the particles that participate in bonds bridging subcompound1 to subcompound2. The user can also opt to provide nothing for one of the paths but will also have to provide a pathway to an object that is only bonded to one other object. This is useful when there is a particle of interest that may randomly form bonds in a system or to simply facilitate the searching process for the user. 

##### bond_swap:
-
> The code has yet to be drafted. I had envisioned that it would heavily rely on the algorithm in find_bonds but I now see the issue where find_bonds yields multiple bonds and it will be difficult to specify which bonds should be swapped.

### Unresolved issues:
- when loading from parmed, the new molecule does not have any hierarchal pathways, just simply the particles and their respective labels. This nullifies the effectiveness of many of the searching functions I have developed (subcompounds_by_name, find_subcompounds_in_path, find_particle_in_path, etc.). In order to allow this functionality to still be available to the user we should either develop a way to preserve hierarchal composition or develop more recipes.
- limit the number of flops in functions like mirror and mirror_child_chirality.
- utilize the .made_from_lattice attribute and add an attribute to track the location of lattices witin a compound hierarchy (have them contain something like a pointer to the corresponding lattice object since they will be very difficult to keep track of in instance where there are many operatations being done on them) so that when they undergoe operations like mirror and rotate, the lattice vectors are updated. By doing this, if at a later time the user wishes to access that lattice object and either utilize the lattice class' .populate or .undo/.redo functions, they will easily and accurately be able to do so.
